options{
  lookahead = 2;
  STATIC = false;
}

PARSER_BEGIN(Assignment)
  import java.util.*;
  public class Assignment{
    //Arraylist for function names and calls to make sure all calls are to functions in the program
    public static ArrayList<String> functionCalls = new ArrayList<String>();
    public static ArrayList<String> functionNames = new ArrayList<String>();
    
    //Stack of function calls to be used in cycle detection of call to functions
    public static Stack<FunctionCall> calls = new Stack<FunctionCall>();

    //create new stack for function parameters to make sure function bodies only used corresponding parameters
    public static Stack<String> functionParams = new Stack<String>();

    //Function map to store function names mapped to their details (parameter and body)
    public static HashMap<String, Function> functionDetails = new HashMap<String, Function>();

    public static void main(String args []) throws Throwable {
      try {
        Expression finalExpression = new Assignment(System.in).Program();
        System.out.println("PASS");
        
        //print out the final expression
        // System.out.println("Final: "+finalExpression);
        System.out.println(expressionEvaluator(finalExpression.toString()));
      } catch (Throwable e) {
        if (e.getMessage().contains("Recursive"))
          System.out.println("DIVERGENCE");
        else {
          System.out.println("Syntax error detected: FAIL");
          
          //check if e is an instance of error
          if (e instanceof Error) {
            System.err.println(getLineNumber(e.getMessage())+"\nWrong character - Non-token found");
          } else 
              System.err.println(e.getMessage());
        }
      }  
    }

    //evaluator for the final expression
    public static int expressionEvaluator(String finalExpression) {
      String numbers = "0123456789";
      String op = "*+";

      char[] characters = finalExpression.toCharArray();
      Stack<Integer> intStack = new Stack<Integer>();
      char last = ' ';

      for (char ch : characters) {
        // System.out.println("Current char: "+ch);
        if (numbers.contains(ch+"")) {
          if (numbers.contains(last+"")) {
            intStack.push(10*(intStack.pop() + (ch - '0')));
          } else
            intStack.push(ch - '0'); // convert char to int val
        } else if (op.contains(ch+"")) {
          int num1 = intStack.pop();
          int num2 = intStack.pop();
          int result;
          
          if (ch == '+') {
            result = num1 + num2; 
            intStack.push(result);
          } else {
            result = num1 * num2;
            intStack.push(result);
          }
        }
        last = ch;
      }
      return intStack.pop();
    }
    
    //function to retrieve line number from string message
    public static int getLineNumber(String exceptionMessage) {
      String temp = exceptionMessage.substring(exceptionMessage.indexOf("line")+5, exceptionMessage.indexOf(","));
      return Integer.parseInt(temp);
    }

    //create a class to represent functions
    public class Function {
      public String param;
      public Expression body;

      //Function constructor
      public Function(String param, Expression body) {
        this.param = param;
        this.body = body;
      }

      //getters, return the function datails - not sure it's needed since it's public
      public String getParam() {
        return param;
      }

      public Expression getBody() {
        return body;
      }
    }

    //create a class to represent expressions
    public abstract class Expression {}

    //create classes for the different types of expressions - numbers, parameters, functioncalls
    //class for numbers
    public class Number extends Expression {
      public int value;

      public Number(int value) {
        this.value = value;
      }

      //toString method for numbers
      public String toString() {
        return "" + value;
      }
    }

    //class for parameters
    public class Parameter extends Expression {
      public String param;

      //Parameter constructor
      public Parameter(String param) {
        this.param = param;
      }

      //toString method for parameters
      public String toString() {
        return param;
      }
    }

    //class for function calls
    public class FunctionCall extends Expression {
      public String functionName;
      public Expression argument;

      //FunctionCall constructor
      public FunctionCall(String name, Expression arg) {
        this.functionName = name;
        this.argument = arg;
      }

      public String toString() {
        if (calls.search(this) > -1) {
          // System.out.println("Error: Recursive function call");
          throw new Error("Wrong Recursive function call");
        }

        calls.push(this);

        String functionBody = functionDetails.get(functionName).getBody().toString();
        String functionParam = functionDetails.get(functionName).getParam();
        
        String result = functionBody.replaceAll(functionParam, argument.toString());

        //comment later
        calls.pop();

        return result;
      }
    }

    //class for binary expressions
    public class Binary extends Expression {
      public Expression left;
      public Expression right;
      public String operator;

      //Binary constructor
      public Binary(Expression left, String op, Expression right) {
        this.left = left; this.right = right;
        this.operator = op;
      }

      //String form with left and right operands and operator
      public String toString() {
        return "(" + left.toString() + "|" + right.toString() + operator + ")";
      }
    }
  }
PARSER_END(Assignment)

//Lexical Specification
SKIP:  { "\t" | "\r" }
//Space
TOKEN: { < SPACE: " " > }
//End of line tokens
TOKEN: { < EOL: "\n" > }
//Arithmetic operators
TOKEN: { < ADD: "+" > | < MUL: "*" > }
//Parenthesis
TOKEN: { < LPAREN: "(" > | < RPAREN: ")" > }
//Curly braces
TOKEN: { < LBRACE: "{" > | < RBRACE: "}" > }
//Semi-colon
TOKEN: { < SCOLON: ";" > }
//Function definition - "DEF" is a reserved word
TOKEN: { < DEF: "DEF" > }
//Function names - "MAIN" is a reserved word
TOKEN: { < MAIN: "MAIN" > | < FUNC: (["A"-"Z"])+ > }
//Parameter names
TOKEN: { < PARAM: (["a"-"z"])+ > }
//Numeric literals
TOKEN: { < NUM: (["0"-"9"])+ > }
//Begining of a function definition
TOKEN: { < DEFINE: <DEF> <SPACE> > }

//Lexical Specification

void Definition() throws Exception: {} {
  try {
    <DEFINE>
  } catch (Exception e) { //Catch error thrown for wrong expression
    if (e.getMessage().contains("EOF")) {
      throw new Exception("0\nWrong Program Structure - Missing Main FUnction");
    }

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Format - must start with (DEF)");
  }
}

//Program consists of one main function and a series of function definitions in any order
//Program -> Function* Main Function*
Expression Program() throws Exception: {Token t; double result;} {
  (Function())* 
  
  try {
    Main()
  }
  catch (Exception e) {
    if (e.getMessage().contains("Wrong"))
      throw e; 

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Program Structure - Missing Main Function");
  }

  try {
    (Function())* 
    <EOF>

    {
    //check if the all functionCalls are in the functionNames list
      for (String call : Assignment.functionCalls) {
        if (!Assignment.functionNames.contains(call.substring(call.indexOf(" ")+1))) {
          String lineNumber = call.substring(0, call.indexOf(" "));
          throw new Exception(lineNumber+"\nWrong call to an undefined function");
        }
      }
    }

  } catch (Exception e) { //Catch error thrown for duplicate main
    //print message
    // System.out.println(e.getMessage());

    if (e.getMessage().contains("Wrong"))
      throw e;

    if (e.getMessage().contains("MAIN")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Program Structure - Duplicate Main Function");
    }

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Naame Format");
  }

  //return the result of the main function
  {return functionDetails.get("MAIN").getBody();}
}

//Main -> MAIN FunctionBody
Expression Main() throws Exception: {Expression ex;} {
  Definition()
  try {
    <MAIN>
    {
      Assignment.functionNames.add("MAIN");
    }
  } catch (Exception e) { //Catch error thrown for missing main function
    if (e.getMessage().contains("DEF")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Format - Function cannot be called DEF");
    }

    if (e.getMessage().contains("FUNC")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Name Format");
    }

    throw new Exception("0\nWrong Program Structure - Missing Main Function");
  }

  try {
    ex = FunctionBody()

    try {
      <SCOLON> <EOL>
    } catch (Exception e) { //Catch error thrown for wrong line terminator
      if (e.getMessage().contains("Wrong"))
        throw e;

      //throw new excpetion with a custom message
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong function terminator");
    }

    {
      functionDetails.put("MAIN", new Function("",ex));
      return ex;
    }
  } catch (Exception e) { //Catch error thrown for incorrect main function Format
    if (e.getMessage().contains("Wrong"))
      throw e;

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Main Function Format"); 
  }
}

//Function -> FUNC PARAM FunctionBody
Expression Function() throws Exception:{ String functionName = ""; Token t; Token p; Expression ex;} {
  Definition()
  try {
    t = <FUNC> 
    { //Check if a function with the same name has already been defined
      functionName = t.image;
      if (functionNames.contains(functionName)) {
        throw new Exception(t.beginLine+"\nWrong Program Structure - '" + functionName + "' already defined");
      } else {
        functionNames.add(functionName);
      }
    } //throw exception and catch it to get line number of param and then add that to the map
    <SPACE> 

    p = <PARAM> 
    {functionParams.push(p.image);} 

    ex = FunctionBody()

    try {
      <SCOLON> <EOL>
    } catch (Exception e) { //Catch error thrown for wrong line terminator
      if (e.getMessage().contains("Wrong"))
        throw e;

      //throw new excpetion with a custom message
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong function terminator");
    }

    {
      functionDetails.put(functionName, new Function(p.image, ex));
      return ex;
    }
  } catch (Exception e) { //Catch error thrown for missing function name
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw message saying the parameter format is wrong
    if (e.getMessage().contains("PARAM"))
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Parameter Format");

    //print the error message
    // System.out.println(e.getMessage());

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Name Format");
  }
}

//FunctionBody -> LBRACE EXPR RBRACE SCOLON EOL
Expression FunctionBody() throws Exception: {Expression ex;} {
  try {
    <SPACE> <LBRACE> <SPACE> 
      ex = Expression()
    <SPACE> <RBRACE> <SPACE>
    {return ex;}
  } catch (Exception e) { //Catch error thrown for wrong expression
    if (e.getMessage().contains("Wrong"))
      throw e;

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Body Format");
  }
}

//split expressions into terms to preserve order of operations
//EXPR -> TERM ADD TERM | TERM
Expression Expression() throws Exception: {Expression left, right;} {
  try {
    left = Term() 
      ( 
        <ADD> right = Term() 
        {left = new Binary(left, "+", right);}
      )*
    {return left;}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new exception with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
  }
}

//TERM -> FACTOR MUL FACTOR | FACTOR
Expression Term() throws Exception: {Expression left, right;} {
  try {
    left = Factor() 
      ( 
        <MUL> right = Factor()
        {left = new Binary(left, "*", right);}
      )*
    {return left;}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new exception with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
  }
}

//FACTOR -> NUM | Function | Parameter
//add check to make sure function calls refer to defined functions in the same file
Expression Factor() throws Exception: {Token num; Expression exp; Token param;} {
  try {
    exp = Function_Call() 
    {return exp;}

    | param = <PARAM> 
      {
        if (!(functionParams.peek().equals(param.image))) {
          throw new Exception(param.beginLine+"\nWrong Parameter within function body");
        }

        return new Parameter(param.image);
      } 

    | num = <NUM>
      {return new Number(Integer.parseInt(num.image));}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong"))
      throw e;
    else {
      //throw new excpetion with a custom message
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
    }
  }
}

//Function_Call -> FUNC LPAREN EXPR RPAREN
Expression Function_Call() throws Exception: {Token name; Expression exp;} {
  try {
    name = <FUNC> 
      {
        //add line number and function call to arraylist of function calls
        functionCalls.add(name.beginLine + " " + name.image);
      }
    <LPAREN> 
      exp = Expression()
    <RPAREN>
    {return new FunctionCall(name.image, exp);}
  } catch (Exception e) { //catch error thrown for incorrect function call Format
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Call Format");
  }
}