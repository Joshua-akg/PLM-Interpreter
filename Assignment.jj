options{
  lookahead = 2;
  STATIC = false;
}

PARSER_BEGIN(Assignment)
  import java.util.*;
  public class Assignment{
    public static ArrayList<String> functionCalls = new ArrayList<String>();
    public static ArrayList<String> functionNames = new ArrayList<String>();

    //Maps function names to their parameters
    public static HashMap<String, Character> functionParams = new HashMap<String, Character>();

    public static void main(String args []) throws Throwable {
      try {
        new Assignment(System.in).Program();
        System.out.println("Syntax is okay: PASS");
      } catch (Throwable e) {
        System.out.println("Syntax error detected: FAIL");

        //check if e is an instance of error
        if (e instanceof Error) {
          System.err.println(getLineNumber(e.getMessage())+"\nNon-Token character found");
        } else 
            System.err.println(e.getMessage());
        // e.printStackTrace();
      }  
    }
    
    
    //function to retrieve line number from string message
    public static int getLineNumber(String exceptionMessage) {
      String temp = exceptionMessage.substring(exceptionMessage.indexOf("line")+5, exceptionMessage.indexOf(","));
      return Integer.parseInt(temp);
    }
  }
PARSER_END(Assignment)

//Lexical Specification

//Space
TOKEN: { < SPACE: " " > }
//End of line tokens
TOKEN: { < EOL: "\n" | "\r" | "\r\n" > }
//End of file
// TOKEN: { <EOF: "\0">}
//Arithmetic operators
TOKEN: { < ADD: "+" > | < MUL: "*" > }
//Parenthesis
TOKEN: { < LPAREN: "(" > | < RPAREN: ")" > }
//Curly braces
TOKEN: { < LBRACE: "{" > | < RBRACE: "}" > }
//Semi-colon
TOKEN: { < SCOLON: ";" > }
//Function definition - reserved word
TOKEN: { < DEF: "DEF" > }
//Main function - reserved word
// TOKEN: { < MAIN: "MAIN" > }
//Function names
TOKEN: { < MAIN: "MAIN" > | < FUNC: (["A"-"Z"])+ > }
//Parameter names
TOKEN: { < PARAM: (["a"-"z"])+ > }
//Numeric literals
TOKEN: { < NUM: (["0"-"9"])+ > }
//Begining of a function definition
//Use of define to eliminate need of lookahead
TOKEN: { < DEFINE: <DEF> <SPACE> > }

//Lexical Specification

void Definition() throws Exception: {} {
  try {
    <DEFINE>
  } catch (Exception e) { //Catch error thrown for wrong expression
    // System.out.println(e.getMessage());
    if (e.getMessage().contains("EOF")) {
      throw new Exception("0\nWrong - Missing Main FUnction");
    }

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Format - must start with (DEF)");
  }
}

//Program consists of one main function and a series of function definitions in any order
//Program -> Function* Main Function*
void Program() throws Exception: {Token t;} {
  (Function())* 
  
  try {
    Main()
  }
  catch (Exception e) {
    if (e.getMessage().contains("Wrong"))
      throw e;

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong - Missing Main Function");

    
  }

  try {
    (Function())* 
    <EOF>

    {
    //check if the all functionCalls are in the functionNames list
      for (String call : Assignment.functionCalls) {
        if (!Assignment.functionNames.contains(call.substring(call.indexOf(" ")+1))) {
          String lineNumber = call.substring(0, call.indexOf(" "));
          throw new Exception(lineNumber+"\nWrong call to an undefined function");
        }
      }
    }

  } catch (Exception e) { //Catch error thrown for duplicate main
    if (e.getMessage().contains("Wrong"))
      throw e;

    //get current line number
    int lineNumber = getLineNumber(e.getMessage());

    if (e.getMessage().contains("MAIN")) {
      throw new Exception(lineNumber+"\nDuplicate Main Function");
    }

    throw new Exception(lineNumber+"\nWrong Function Format"); 
  }
}

//Main -> MAIN FunctionBody
void Main() throws Exception: {} {
  Definition()
  try {
    <MAIN>
    {
      Assignment.functionNames.add("MAIN");
    }
  } catch (Exception e) { //Catch error thrown for missing main function

    //get current line number
    int lineNumber = getLineNumber(e.getMessage());
    if (e.getMessage().contains("DEF")) {
      throw new Exception(lineNumber+"\nWrong Format - Function cannot be called DEF");
    }

    if (e.getMessage().contains("FUNC")) {
      throw new Exception(lineNumber+"\nWrong Function Name Format");
    }

    lineNumber = 0;
    throw new Exception(lineNumber+"\nMissing Main Function");
  }

  try {
    FunctionBody()
  } catch (Exception e) { //Catch error thrown for incorrect main function Format
    if (e.getMessage().contains("Wrong"))
      throw e;

    //get current line number
    int lineNumber = getLineNumber(e.getMessage());
    throw new Exception(lineNumber+"\nWrong Main Function Format"); 
  }
}

//Function -> FUNC PARAM FunctionBody
void Function() throws Exception:
{ String functionName = "";
  Token t;} 
{
  Definition()
  try {
    t = <FUNC> 
    { //Check if a function with the same name has already been defined
      functionName = t.image;
      if (functionNames.contains(functionName)) {
        throw new Exception(t.beginLine+"\nWrong Function Definition - '" + functionName + "' already defined");
      } else {
        functionNames.add(functionName);
      }
    } //throw exception and catch it to get line number of param and then add that to the map
    <SPACE> <PARAM> FunctionBody()
  } catch (Exception e) { //Catch error thrown for missing function name
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }
    
    //extract line number from Exception
    int lineNumber = getLineNumber(e.getMessage());

    //throw message saying the parameter format is wrong
    if (e.getMessage().contains("PARAM"))
      throw new Exception(lineNumber+"\nWrong Parameter Format");

    //throw new excpetion with a custom message
    throw new Exception(lineNumber+"\nWrong Function Name Format");
  }
}

//FunctionBody -> LBRACE EXPR RBRACE SCOLON EOL
void FunctionBody() throws Exception: {} {
  try {
  <SPACE> <LBRACE> <SPACE> Expression() <SPACE> <RBRACE> <SPACE>
  } catch (Exception e) { //Catch error thrown for wrong expression
    //extract line number from Exception

    if (e.getMessage().contains("Wrong"))
      throw e;

    int lineNumber = getLineNumber(e.getMessage());

    //throw new exception with custom message
    // if (e.getMessage().contains("PARAM"))
    // System.out.println(e.getMessage());
    //   throw new Exception(lineNumber+"\nWrong Parameter Foormat"); //what does this fix?

    throw new Exception(lineNumber+"\nWrong Function Body Format");
  }  
    <SCOLON> //might give its own try-catch

  try {
    <EOL>
  } catch (Exception e) { //Catch error thrown for wrong line terminator
    if (e.getMessage().contains("Wrong"))
      throw e;
    
    int lineNumber = getLineNumber(e.getMessage());

    //throw new excpetion with a custom message
    throw new Exception(lineNumber+"Invalid line terminator");
  }
}

//EXPR -> TERM ADD TERM | TERM
void Expression() throws Exception: {} {
  try {
    Term() ( <ADD> Term() )*
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //extract line number from Exception
    int lineNumber = getLineNumber(e.getMessage());

    //throw new excpetion with a custom message
    throw new Exception(lineNumber+"\nWrong Expression Format");
  }
}

//TERM -> FACTOR MUL FACTOR | FACTOR
void Term() throws Exception: {} {
  try {
    Factor() ( <MUL> Factor() )*
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //extract line number from Exception
    int lineNumber = getLineNumber(e.getMessage());

    //throw new excpetion with a custom message
    throw new Exception(lineNumber+"\nWrong Expression Format");
  }
}

//FACTOR -> NUM | Function | Parameter
//add check to make sure function calls refer to defined functions in the same file
void Factor() throws Exception: {} {
  try {
    Function_Call() | <PARAM> | <NUM>
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong"))
      throw e;
    else {
      //extract line number from Exception
      int lineNumber = getLineNumber(e.getMessage());

      //throw new excpetion with a custom message
      throw new Exception(lineNumber+"\nWrong Expression Format");
    }
  }
}

//Function_Call -> FUNC LPAREN EXPR RPAREN
void Function_Call() throws Exception:
{Token t;}
{
  try {
    t = <FUNC> 
    {
      //add to arraylist of function calls
      functionCalls.add(t.beginLine + " " + t.image);
    }
    <LPAREN> Expression() <RPAREN>
  } catch (Exception e) { //catch error thrown for incorrect function call Format
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }
    
    //extract line number from Exception
    int lineNumber = getLineNumber(e.getMessage());

    //throw new excpetion with a custom message
    throw new Exception(lineNumber+"\nWrong Function Call Format");
  }
}