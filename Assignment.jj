options{
  lookahead = 2;
  STATIC = false;
}

PARSER_BEGIN(Assignment)
  import java.util.*;
  public class Assignment{
    public static final String TEXT_RESET = "\u001B[0m";
    public static final String TEXT_RED = "\u001B[31m";
    public static final String TEXT_GREEN = "\u001B[32m";

    //Arraylist for function names and calls to make sure all calls are to functions in the program
    public static ArrayList<String> functionCalls = new ArrayList<String>();
    public static ArrayList<String> functionNames = new ArrayList<String>();
    
    //Stack of function calls to be used in cycle detection of call to functions
    public static Stack<FunctionCall> calls = new Stack<FunctionCall>();

    //create new stack for function parameters to make sure function bodies only used corresponding parameters
    public static Stack<String> functionParams = new Stack<String>();

    //Function map to store function names mapped to their details (parameter and body)
    public static HashMap<String, Function> functionDetails = new HashMap<String, Function>();

    public static void main(String args []) throws Throwable {
      try {
        Expression finalExpression = new Assignment(System.in).Program();

        //print the result of parsing the PLM
        System.out.println(TEXT_GREEN + "PASS" + TEXT_RESET);
        
        //print the result of evaluating the PLM
        System.out.println(TEXT_GREEN + expressionEvaluator(finalExpression.toString()) + TEXT_RESET);
      } catch (Throwable e) {
        //catch errors thrown from programs which do not evaluate to a number
        if (e.getMessage().contains("Recursive"))
          System.out.println(TEXT_GREEN + "DIVERGENCE" + TEXT_RESET);
        else {
          //print the result of parsing the PLM
          System.out.println(TEXT_GREEN + "FAIL" + TEXT_RESET);
          
          //check if e is an error vs an exception, which would be thrown if a non-token is found
          if (e instanceof Error) {
            System.err.println(TEXT_RED + getLineNumber(e.getMessage())+"\nWrong character - Non-token found" + TEXT_RESET);
          } else
            //Otherwise print whatever exception was thrown by the parser
              System.err.println(TEXT_RED + e.getMessage() + TEXT_RESET);
        }
      }  
    }

    //evaluator for the final expression
    public static int expressionEvaluator(String finalExpression) {
      //declare the numbers and operators expected in the expression
      String numbers = "0123456789";
      String op = "*+";

      //convert expression to a character array
      char[] characters = finalExpression.toCharArray();

      //declare a stack to store the numbers used in the evaluation
      Stack<Integer> intStack = new Stack<Integer>();

      //declare a last character to use in checking if numbers consist of multiple digits
      char last = ' ';

      //loop through all characters in the final expression
      for (char ch : characters) {
        //if the character is a number
        if (numbers.contains(ch+"")) {
          //check if the last character was also a number
          if (numbers.contains(last+"")) {
            //if it was then remove the last number from the stack and add the current number to it times 10
            intStack.push(10*(intStack.pop() + (ch - '0')));
          } else    //otherwise just add the current number to the stack
            intStack.push(ch - '0');

        //if the current character is an operator
        } else if (op.contains(ch+"")) {
          //pop the last two numbers from the stack and perform the operation
          int num1 = intStack.pop();
          int num2 = intStack.pop();
          int result;
          
          if (ch == '+') {
            result = num1 + num2; 
            intStack.push(result);
          } else {
            result = num1 * num2;
            intStack.push(result);
          }
        }
        //set the last character to the current character just checked
        last = ch;
      }
      //return the final result on the stack
      return intStack.pop();
    }
    
    //function to retrieve line number from string message
    public static int getLineNumber(String exceptionMessage) {
      //find where the message says "line" and then get the number after it
      String temp = exceptionMessage.substring(exceptionMessage.indexOf("line")+5, exceptionMessage.indexOf(","));
      return Integer.parseInt(temp);
    }

    //create a class to represent functions
    public class Function {
      //functions consists of parameters and a body which is an expression
      public String param;
      public Expression body;

      //Function constructor
      public Function(String param, Expression body) {
        this.param = param;
        this.body = body;
      }

      //getters, return the function datails - not sure it's needed since it's public
      public String getParam() {
        return param;
      }

      public Expression getBody() {
        return body;
      }
    }

    //create a class to represent expressions
    //declare as abstract since expressions come in multiple types
    public abstract class Expression {}

    //create classes for the different types of expressions - numbers, parameters, functioncalls
    //class for numbers
    public class Number extends Expression {
      //declare the integer value of the number
      public int value;

      public Number(int value) {
        this.value = value;
      }

      //toString method for numbers - produces the string representation of a number
      public String toString() {
        return "" + value;
      }
    }

    //class for parameters
    public class Parameter extends Expression {
      //declare the parameter name
      public String param;

      //Parameter constructor
      public Parameter(String param) {
        this.param = param;
      }

      //toString method for parameters - produces the string representation of a parameter
      public String toString() {
        return param;
      }
    }

    //class for function calls
    public class FunctionCall extends Expression {
      //declare the function name and the argument expression of the function call
      public String functionName;
      public Expression argument;

      //FunctionCall constructor
      public FunctionCall(String name, Expression arg) {
        this.functionName = name;
        this.argument = arg;
      }

      //toString method for function calls - produces the string representation of a function call
      public String toString() {
        //search the call stack to see if a function call has already been made
        //meaning there would be a cycle and the expression produced does not evaluate to a number
        if (calls.search(this) > -1) {
          throw new Error("Wrong Recursive function call");
        }

        //if the function call is not in the call stack, add it to the stack
        calls.push(this);

        //get the string representation of the function body and parameter 
        String functionBody = functionDetails.get(functionName).getBody().toString();
        String functionParam = functionDetails.get(functionName).getParam();
        
        //replace the parameter in the function body with the argument
        String result = functionBody.replaceAll(functionParam, argument.toString());

        //after retrieving the expression which the function call produces
        //remove it from the stack
        //so it may be called again from other functions without creating a cycle
        calls.pop();

        //return the expression created by the function call
        return result;
      }
    }

    //class for binary expressions
    public class Binary extends Expression {
      //declare the expressions and the operator which a binary expression consists of
      public Expression left;
      public Expression right;
      public String operator;

      //Binary expression constructor
      public Binary(Expression left, String op, Expression right) {
        this.left = left; this.right = right;
        this.operator = op;
      }

      //Return the String form with left and right operands and operator
      public String toString() {
        //return the string representations of the left and right operands and operator
        //returned in this order (post-fix) to allow for post-fix evaluation
        return "(" + left.toString() + "|" + right.toString() + operator + ")";
      }
    }
  }
PARSER_END(Assignment)

//Lexical Specification
SKIP:  { "\t" | "\r" }
//Space
TOKEN: { < SPACE: " " > }
//End of line tokens
TOKEN: { < EOL: "\n" > }
//Arithmetic operators
TOKEN: { < ADD: "+" > | < MUL: "*" > }
//Parenthesis
TOKEN: { < LPAREN: "(" > | < RPAREN: ")" > }
//Curly braces
TOKEN: { < LBRACE: "{" > | < RBRACE: "}" > }
//Semi-colon
TOKEN: { < SCOLON: ";" > }
//Function definition - "DEF" is a reserved word
TOKEN: { < DEF: "DEF" > }
//Function names - "MAIN" is a reserved word
TOKEN: { < MAIN: "MAIN" > | < FUNC: (["A"-"Z"])+ > }
//Parameter names
TOKEN: { < PARAM: (["a"-"z"])+ > }
//Numeric literals
TOKEN: { < NUM: (["0"-"9"])+ > }
//Begining of a function definition
TOKEN: { < DEFINE: <DEF> <SPACE> > }

void Definition() throws Exception: {} {
  try {
    <DEFINE>
  } catch (Exception e) { //Catch error thrown for wrong expression
    if (e.getMessage().contains("EOF")) {
      throw new Exception("0\nWrong Program Structure - Missing Main Function");
    }

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Format - must start with (DEF)");
  }
}

//Program consists of one main function and a series of function definitions in any order
//Program -> Function* Main Function*
Expression Program() throws Exception: {Token t; double result;} {
  (Function())* 
  
  try {
    Main()
  }
  catch (Exception e) {
    if (e.getMessage().contains("Wrong"))
      throw e; 

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Program Structure - Missing Main Function");
  }

  try {
    (Function())* 
    <EOF>

    {
    //check if the all functionCalls are in the functionNames list
      for (String call : Assignment.functionCalls) {
        //if a function call is not in the functionNames list, throw an exception
        if (!Assignment.functionNames.contains(call.substring(call.indexOf(" ")+1))) {
          String lineNumber = call.substring(0, call.indexOf(" "));
          throw new Exception(lineNumber+"\nWrong call to an undefined function");
        }
      }
    }

  } catch (Exception e) { //Catch error thrown for duplicate main
    //if the message contains a "Wrong", propagate the exception
    if (e.getMessage().contains("Wrong"))
      throw e;

    if (e.getMessage().contains("MAIN")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Program Structure - Duplicate Main Function");
    }

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Naame Format");
  }

  //return the expression body of the main function
  {return functionDetails.get("MAIN").getBody();}
}

//Main -> MAIN FunctionBody
Expression Main() throws Exception: {Expression ex;} {
  Definition()
  try {
    <MAIN>
    {
      //add the function name "main" to the functionNames list
      Assignment.functionNames.add("MAIN");
    }
  } catch (Exception e) { //Catch possible exceptions that can be thrown
    if (e.getMessage().contains("DEF")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Format - Function cannot be called DEF");
    }

    if (e.getMessage().contains("FUNC")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Name Format");
    }

    //catch exception for missing main function
    throw new Exception("0\nWrong Program Structure - Missing Main Function");
  }

  try {
    //let the expression to be returned be the expression in the function body
    ex = FunctionBody()

    try {
      //check that the function ends properly
      <SCOLON> <EOL>
    } catch (Exception e) { //Catch possible exceptions that can be thrown
      //propagate other exceptions
      if (e.getMessage().contains("Wrong"))
        throw e;

      //Catch error thrown for wrong line terminator
      //throw new excpetion with a custom message
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong function terminator");
    }

    {
      //add the main function's details to the hashmap
      functionDetails.put("MAIN", new Function("",ex));
      return ex;
    }
  } catch (Exception e) { //Catch error thrown for incorrect main function Format
    if (e.getMessage().contains("Wrong"))
      throw e;

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Main Function Format"); 
  }
}

//Function -> FUNC PARAM FunctionBody
Expression Function() throws Exception:{ String functionName = ""; Token t; Token p; Expression ex;} {
  Definition()
  try {
    t = <FUNC> 
    { 
      //Check if a function with the same name has already been defined
      functionName = t.image;

      //if it has, throw a new exception as there's a duplicate function
      if (functionNames.contains(functionName)) {
        throw new Exception(t.beginLine+"\nWrong Program Structure - '" + functionName + "' already defined");
      } else {
        functionNames.add(functionName);
      }
    } 

    <SPACE> 

    p = <PARAM> 
    {functionParams.push(p.image);} 

    //set the resulting expression to be the function body
    ex = FunctionBody()

    try {
      //check that the function ends properly
      <SCOLON> <EOL>
    } catch (Exception e) { 
      //propagrate thrown exception
      if (e.getMessage().contains("Wrong"))
        throw e;

      //Catch error thrown for wrong line terminator
      //throw new exception with a custom message
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong function terminator");
    }

    {
      //add the function's details to the hashmap
      functionDetails.put(functionName, new Function(p.image, ex));
      return ex;
    }
  } catch (Exception e) { //Catch error thrown for missing function name
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw message saying the parameter format is wrong
    if (e.getMessage().contains("PARAM"))
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Parameter Format");

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Name Format");
  }
}

//FunctionBody -> LBRACE EXPR RBRACE SCOLON EOL
Expression FunctionBody() throws Exception: {Expression ex;} {
  try {
    <SPACE> <LBRACE> <SPACE>
    //set the resulting expression to that contained within the body
      ex = Expression()
    <SPACE> <RBRACE> <SPACE>
    {return ex;}
  } catch (Exception e) {
    //propagate exception
    if (e.getMessage().contains("Wrong"))
      throw e;

    //catch exception for wrong function body format 
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Body Format");
  }
}

//split expressions into terms to preserve order of operations
//EXPR -> TERM ADD TERM | TERM    //after factorisation
Expression Expression() throws Exception: {Expression left, right;} {
  try {
    left = Term() 
      ( 
        <ADD> right = Term()
        //return the binary expression generated by the left and right terms
        {left = new Binary(left, "+", right);}
      )*
    {return left;}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new exception with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
  }
}

//TERM -> FACTOR MUL FACTOR | FACTOR
Expression Term() throws Exception: {Expression left, right;} {
  try {
    left = Factor() 
      ( 
        <MUL> right = Factor()
        //return the binary expression generated by the left and right terms
        {left = new Binary(left, "*", right);}
      )*
    {return left;}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new exception with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
  }
}

//FACTOR -> NUM | Function | Parameter
//add check to make sure function calls refer to defined functions in the same file
Expression Factor() throws Exception: {Token num; Expression exp; Token param;} {
  try {
    exp = Function_Call() 
    {return exp;}

    | param = <PARAM> 
      {
        if (!(functionParams.peek().equals(param.image))) {
          throw new Exception(param.beginLine+"\nWrong Parameter within function body");
        }

        return new Parameter(param.image);
      } 

    | num = <NUM>
      {return new Number(Integer.parseInt(num.image));}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong"))
      throw e;
    else {
      //throw new excpetion with a custom message
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
    }
  }
}

//Function_Call -> FUNC LPAREN EXPR RPAREN
Expression Function_Call() throws Exception: {Token name; Expression exp;} {
  try {
    name = <FUNC> 
      {
        //add line number and function call to arraylist of function calls
        functionCalls.add(name.beginLine + " " + name.image);
      }
    <LPAREN> 
      exp = Expression()
    <RPAREN>
    {return new FunctionCall(name.image, exp);}
  } catch (Exception e) { //catch error thrown for incorrect function call Format
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Call Format");
  }
}