//set lookahead to 2
options{
  lookahead = 2;
  STATIC = false;
}

PARSER_BEGIN(Assignment)
  public class Assignment{
    public static void main(String args []) throws Exception {
      try {
        new Assignment(System.in).Program();
        System.out.println("Syntax is okay");
      } catch (Exception e) {
        System.out.println("Syntax failure: " + e.getMessage());
      }     
    }
  }

PARSER_END(Assignment)

//Lexical Specification

//Space
TOKEN: { < SPACE: " " > }
//End of line tokens
TOKEN: { < EOL: "\n" | "\r" | "\r\n" > }
//End of file
// TOKEN: { <EOF: "\0">}
//Arithmetic operators
TOKEN: { < ADD: "+" > | < MUL: "*" > }
//Parenthesis
TOKEN: { < LPAREN: "(" > | < RPAREN: ")" > }
//Curly braces
TOKEN: { < LBRACE: "{" > | < RBRACE: "}" > }
//Semi-colon
TOKEN: { < SCOLON: ";" > }
//Function definition - reserved word
TOKEN: { < DEF: "DEF" > }
//Main function - reserved word
// TOKEN: { < MAIN: "MAIN" > }
//Function names
TOKEN: { < MAIN: "MAIN" > | < FUNC: (["A"-"Z"])+ > }
//Parameter names
TOKEN: { < PARAM: (["a"-"z"])+ > }
//Numeric literals
TOKEN: { < NUM: (["0"-"9"])+ > }
//Begining of a function definition
//Use of define to eliminate need of lookahead
TOKEN: { < DEFINE: <DEF> <SPACE> > }

//Lexical Specification

//Program consists of the main function and a series of function definitions
//Program -> Main Function | Function Definition
void Program(): {} {
  (<DEFINE> Function())* 
  <DEFINE> Main()
  (<DEFINE> Function())*
  <EOF>  
}

//(<DEFINE> (Function))* (<DEFINE> Main()) (<DEFINE> (Function))* <EOF>

//Main -> DEF MAIN FUNFunctionBody
void Main(): {} {
  <MAIN> <SPACE> FunctionBody()
}

//Function -> FUNC PARAM FunctionBody
void Function(): {} {
  <FUNC> <SPACE> <PARAM> <SPACE> FunctionBody()
}

//FunctionBody -> LBRACE EXPR RBRACE SCOLON EOL
void FunctionBody(): {} {
  <LBRACE> <SPACE> (Expression()) <SPACE> <RBRACE> <SPACE> <SCOLON> <EOL>
}

//Function_Call -> FUNC LPAREN EXPR RPAREN
void Function_Call(): {} {
  <FUNC> <LPAREN> Expression() <RPAREN>
}

//EXPR -> TERM ADD TERM | TERM
void Expression(): {} {
  Term() ( <ADD> Term() )*
}

//TERM -> FACTOR MUL FACTOR | FACTOR
void Term(): {} {
  Factor() ( <MUL> Factor() )*
}

//FACTOR -> NUM | Function | Parameter
void Factor(): {} {
  <NUM> | Function_Call() | <PARAM>
}