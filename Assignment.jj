options{
  lookahead = 2;
  STATIC = false;
}

PARSER_BEGIN(Assignment)
  import java.util.*;
  public class Assignment{
    //Arraylist for function names and calls to make sure all calls are to functions in the program
    public static ArrayList<String> functionCalls = new ArrayList<String>();
    public static ArrayList<String> functionNames = new ArrayList<String>();
    
    //create new stack for function parameters to make sure function bodies only used corresponding parameters
    public static Stack<String> functionParams = new Stack<String>();

    //Function map to store function names mapped to their details (parameter and body)
    public static HashMap<String, Function> functionDetails = new HashMap<String, Function>();

    public static void main(String args []) throws Throwable {
      try {
        new Assignment(System.in).Program();
        System.out.println("Syntax is okay: PASS");
      } catch (Throwable e) {
        System.out.println("Syntax error detected: FAIL");
        
        //check if e is an instance of error
        if (e instanceof Error) {
          System.err.println(getLineNumber(e.getMessage())+"\nWrong character - Non-token found");
        } else 
            System.err.println(e.getMessage());
        // e.printStackTrace();
      }  
    }
    
    //function to retrieve line number from string message
    public static int getLineNumber(String exceptionMessage) {
      String temp = exceptionMessage.substring(exceptionMessage.indexOf("line")+5, exceptionMessage.indexOf(","));
      return Integer.parseInt(temp);
    }

    //create a class to represent functions
    public class Function {
      public String param;
      public Expression body;

      //Function constructor
      public Function(String param, Expression body) {
        this.param = param;
        this.body = body;
      }

      //getters, return the function details - not sure it's needed since it's public
      public String getParam() {
        return param;
      }

      public Expression getBody() {
        return body;
      }
    }

    //create a class to represent expressions
    public abstract class Expression {}

    //create classes for the different types of expressions - numbers, parameters, functioncalls
    
    //class for numbers
    public class Number extends Expression {
      public int value;

      public Number(int value) {
        this.value = value;
      }
    }

    //class for parameters
    public class Parameter extends Expression {
      public String param;

      //Parameter constructor
      public Parameter(String param) {
        this.param = param;
      }
    }

    //class for function calls
    public class FunctionCall extends Expression {
      public String functionName;
      public Expression argument;

      //FunctionCall constructor
      public FunctionCall(String name, Expression arg) {
        this.functionName = name;
        this.argument = arg;
      }

      //string form with parameters replaced
      // public String get
    }

    //class for binary expressions
    public class Binary extends Expression {
      public Expression left;
      public Expression right;
      public String operator;

      //Binary constructor
      public Binary(Expression left, String op, Expression right) {
        this.left = left;
        this.right = right;
        this.operator = op;
      }

      //String form with left and right operands and operator
    }
  }
PARSER_END(Assignment)

//Lexical Specification
SKIP:  { "\t" | "\r" }
//Space
TOKEN: { < SPACE: " " > }
//End of line tokens
TOKEN: { < EOL: "\n" > }
//Arithmetic operators
TOKEN: { < ADD: "+" > | < MUL: "*" > }
//Parenthesis
TOKEN: { < LPAREN: "(" > | < RPAREN: ")" > }
//Curly braces
TOKEN: { < LBRACE: "{" > | < RBRACE: "}" > }
//Semi-colon
TOKEN: { < SCOLON: ";" > }
//Function definition - "DEF" is a reserved word
TOKEN: { < DEF: "DEF" > }
//Function names - "MAIN" is a reserved word
TOKEN: { < MAIN: "MAIN" > | < FUNC: (["A"-"Z"])+ > }
//Parameter names
TOKEN: { < PARAM: (["a"-"z"])+ > }
//Numeric literals
TOKEN: { < NUM: (["0"-"9"])+ > }
//Begining of a function definition
TOKEN: { < DEFINE: <DEF> <SPACE> > }

//Lexical Specification

void Definition() throws Exception: {} {
  try {
    <DEFINE>
  } catch (Exception e) { //Catch error thrown for wrong expression
    if (e.getMessage().contains("EOF")) {
      throw new Exception("0\nWrong Program Structure - Missing Main FUnction");
    }

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Format - must start with (DEF)");
  }
}

//Program consists of one main function and a series of function definitions in any order
//Program -> Function* Main Function*
void Program() throws Exception: {Token t; double result;} {
  (Function())* 
  
  try {
    Main()
  }
  catch (Exception e) {
    if (e.getMessage().contains("Wrong"))
      throw e; 

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Program Structure - Missing Main Function");
  }

  try {
    (Function())* 
    <EOF>

    {
    //check if the all functionCalls are in the functionNames list
      for (String call : Assignment.functionCalls) {
        if (!Assignment.functionNames.contains(call.substring(call.indexOf(" ")+1))) {
          String lineNumber = call.substring(0, call.indexOf(" "));
          throw new Exception(lineNumber+"\nWrong call to an undefined function");
        }
      }
    }

  } catch (Exception e) { //Catch error thrown for duplicate main
    //print message
    // System.out.println(e.getMessage());

    if (e.getMessage().contains("Wrong"))
      throw e;

    if (e.getMessage().contains("MAIN")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Program Structure - Duplicate Main Function");
    }

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Name Format");
  }
}

//Main -> MAIN FunctionBody
void Main() throws Exception: {} {
  Definition()
  try {
    <MAIN>
    {
      Assignment.functionNames.add("MAIN");
    }
  } catch (Exception e) { //Catch error thrown for missing main function
    if (e.getMessage().contains("DEF")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Format - Function cannot be called DEF");
    }

    if (e.getMessage().contains("FUNC")) {
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Name Format");
    }

    throw new Exception("0\nWrong Program Structure - Missing Main Function");
  }

  try {
    FunctionBody()
  } catch (Exception e) { //Catch error thrown for incorrect main function Format
    if (e.getMessage().contains("Wrong"))
      throw e;

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Main Function Format"); 
  }
}

//Function -> FUNC PARAM FunctionBody
void Function() throws Exception:{ String functionName = ""; Token t; Token p;} {
  Definition()
  try {
    t = <FUNC> 
    { //Check if a function with the same name has already been defined
      functionName = t.image;
      if (functionNames.contains(functionName)) {
        throw new Exception(t.beginLine+"\nWrong Program Structure - '" + functionName + "' already defined");
      } else {
        functionNames.add(functionName);
      }
    } //throw exception and catch it to get line number of param and then add that to the map
    <SPACE> 

    p = <PARAM> 
    {functionParams.push(p.image);} 

    FunctionBody()
  } catch (Exception e) { //Catch error thrown for missing function name
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw message saying the parameter format is wrong
    if (e.getMessage().contains("PARAM"))
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Parameter Format");

    //print the error message
    // System.out.println(e.getMessage());

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Name Format");
  }
}

//FunctionBody -> LBRACE EXPR RBRACE SCOLON EOL
void FunctionBody() throws Exception: {} {
  try {
  <SPACE> <LBRACE> <SPACE> Expression() <SPACE> <RBRACE> <SPACE>
  } catch (Exception e) { //Catch error thrown for wrong expression
    //extract line number from Exception

    if (e.getMessage().contains("Wrong"))
      throw e;

    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Body Format");
  }  
    <SCOLON> //might give its own try-catch

  try {
    <EOL>
  } catch (Exception e) { //Catch error thrown for wrong line terminator
    if (e.getMessage().contains("Wrong"))
      throw e;
    
    int lineNumber = getLineNumber(e.getMessage());

    //throw new excpetion with a custom message
    throw new Exception(lineNumber+"\nWrong function terminator");
  }
}

//split expressions into terms to preserve order of operations
//EXPR -> TERM ADD TERM | TERM
Expression Expression() throws Exception: {Expression left, right;} {
  try {
    left = Term() 
      ( 
        <ADD> right = Term() 
        {left = new Binary(left, "+", right);}
      )*
    {return left;}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new exception with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
  }
}

//TERM -> FACTOR MUL FACTOR | FACTOR
Expression Term() throws Exception: {Expression left, right;} {
  try {
    left = Factor() 
      ( 
        <MUL> right = Factor()
        {left = new Binary(left, "*", right);}
      )*
    {return left;}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new exception with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
  }
}

//FACTOR -> NUM | Function | Parameter
//add check to make sure function calls refer to defined functions in the same file
Expression Factor() throws Exception: {Token num; Expression exp; Token param;} {
  try {
    exp = Function_Call() 
    {return exp;}

    | param = <PARAM> 
      {
        if (!(functionParams.peek().equals(param.image))) {
          throw new Exception(param.beginLine+"\nWrong Parameter within function body");
        }

        return new Parameter(param.image);
      } 

    | num = <NUM>
      {return new Number(Integer.parseInt(num.image));}
  } catch (Exception e) {
    if (e.getMessage().contains("Wrong"))
      throw e;
    else {
      //throw new excpetion with a custom message
      throw new Exception(getLineNumber(e.getMessage())+"\nWrong Expression Format");
    }
  }
}

//Function_Call -> FUNC LPAREN EXPR RPAREN
Expression Function_Call() throws Exception: {Token name; Expression exp;} {
  try {
    name = <FUNC> 
      {
        //add line number and function call to arraylist of function calls
        functionCalls.add(name.beginLine + " " + name.image);
      }
    <LPAREN> 
      exp = Expression()
      {return new FunctionCall(name.image, exp);}
    <RPAREN>
  } catch (Exception e) { //catch error thrown for incorrect function call Format
    if (e.getMessage().contains("Wrong")) {
      throw e;
    }

    //throw new excpetion with a custom message
    throw new Exception(getLineNumber(e.getMessage())+"\nWrong Function Call Format");
  }
}